#!/bin/bash
# vim: ft=sh

set -e

# Mountpoint for top-level btrfs subvolume, must be listed in /etc/fstab
BTRFS_MOUNT="/root/btrfs-top-lvl"

function usage_install {
    printf "%s install [-s] [-b INSTALLATION] [-f FILTER] IMAGE\n" "${0##*/}"
}

function usage_list {
    printf "%s list [-rs]\n" "${0##*/}"
}

function usage_prune {
    printf "%s prune [-k KEEP]\n" "${0##*/}"
}

function usage_stage {
    printf "%s stage [-f] INSTALLATION\n" "${0##*/}"
}

function usage_unstage {
    printf "%s unstage\n" "${0##*/}"
}

function usage_reboot {
    printf "%s reboot\n" "${0##*/}"
}

function usage_persist {
    printf "%s persist\n" "${0##*/}"
}

function usage_all {
    cat <<EOF
Usage:
${0##*/} [<global>] <command> [<args>]

Global Options:
    -h  Show this help message
    -v  Verbose output

Usage of subcommands:

$(usage_install)
    Install IMAGE file under a new snapshot.
    -s  Directly stage that installation afterwards.
    -b  Specifies a different base subvolume which will be the basis for the
        snapshot instead of the currently running subvolume.
    -f  Filter file for rsync to use.
        Default: 'usr/share/svup/upgrade.filter' in the new image.
$(usage_list)
    List the names of all available installed subvolumes.
    -r  Print only the running subvolume.
    -s  Print only the staged subvolume. If nothing is staged, exit with code 9.
$(usage_prune)
    Prune oldest subvolumes with unused installations. The currently running
    or staged subvolume will be skipped and never deleted.
    -d  Dry run. Only print the names of subvolumes that would be deleted, but
        don't do anything.
    -k  How many subvolumes to keep. Staged and running sobvolumes are not
        counted, so specifying 0 would delete all "unused" subvolumes.
        Default: 2.
$(usage_stage)
    Prepare a subvolume for booting with '${0##*/} reboot'.
    -f  Force. If any installation is already staged, allow overwriting it.
$(usage_unstage)
    Unstage the currently staged version again.
$(usage_reboot)
    Try booting into the staged version. Fails if nothing is currently staged.
$(usage_persist)
    Confirm that the new version works and make it persistent across regular
    reboots.

INSTALLATION can either be just the name of a subvolume, for example
'root5', or a full path pointing to the subvolume, for example
'${BTRFS_MOUNT}/root5'.
EOF
}


# Ensures btrfs top-level subvolume is mounted
function mount_btrfs_top {
    ROOT_DEV="$(findmnt -nv -o source /)"
    if ! findmnt "${BTRFS_MOUNT}" > /dev/null; then
        mount -t btrfs "${ROOT_DEV}" "${BTRFS_MOUNT}"
    fi
}

function find_subvolume {
    # Accept both a subvolume name (i.e. 'root5') or a full path
    if [[ -d "$1" ]]; then
        echo "$1"
    elif [[ -d "${BTRFS_MOUNT}/$1" ]]; then
        echo "${BTRFS_MOUNT}/$1"
    else
        printf "Could not find subvolume %s\n" "$1" >&2
        exit 3
    fi
}

function install_img {
    local STAGE=0
    local BASE="/"
    local FILTER=""
    while getopts 'sb:f:' OPTION
    do
        case ${OPTION} in
            s) STAGE=1
                ;;
            b) BASE="${OPTARG}"
                ;;
            f) FILTER="${OPTARG}"
                ;;
            ?) printf "Usage:\n%s\n" "$(usage_install)" >&2
                exit 2
                ;;
        esac
    done
    shift $((OPTIND - 1))
    unset OPTIND

    if [[ $# != 1 ]]; then
        printf "Missing image path\n%s\n" "$(usage_install)" >&2
        exit 2
    fi
    local IMAGE_PATH="$1"
    IMAGE_MOUNT="/mnt/svup/image"

    #TODO Image validation

    LOOP_DEV=$(losetup -f -P --show "${IMAGE_PATH}")

    # Unmount image when encountering any error
    trap 'echo "An error occured during installation, cleaning up"; _clean_install' ERR

    mkdir -p ${IMAGE_MOUNT}
    mount -o ro,subvol=/root -t btrfs "${LOOP_DEV}p2" ${IMAGE_MOUNT}
    mount -o ro -t vfat "${LOOP_DEV}p1" "${IMAGE_MOUNT}/boot"

    mount_btrfs_top

    local SNAPSHOT_TEMP="${BTRFS_MOUNT}/root-temp"
    if [[ -e "${SNAPSHOT_TEMP}" ]]; then
        echo "Partial installation from a previous aborted run found. Deleting..."
        btrfs subvolume delete "${SNAPSHOT_TEMP}"
    fi
    btrfs subvolume snapshot "$(find_subvolume "${BASE}")" "${SNAPSHOT_TEMP}"

    FILTER="${FILTER:-${SNAPSHOT_TEMP}/usr/share/svup/upgrade.filter}"

    # Copy over changes
    rsync --delete --inplace -aAXHx \
        -f ". ${FILTER}" \
        --info=stats2,progress2,misc1,flist0 \
        "${IMAGE_MOUNT}/" "${SNAPSHOT_TEMP}"

    # Put /boot into /boot-save
    rsync -a "${IMAGE_MOUNT}/boot/" "${SNAPSHOT_TEMP}/boot-save"

    # Modify /etc/fstab and /boot/cmdline.txt:
    # Set the correct subvolume and use the current PARTUUID
    local OLD_DISKID
    local NEW_DISKID
    OLD_DISKID=$(grep -oP -m 1 "(?<=PARTUUID=)[0-9a-f]+(?=.*\s/\s)" "${SNAPSHOT_TEMP}/etc/fstab")
    NEW_DISKID=$(lsblk -no PTUUID "${ROOT_DEV}")

    # Find previous highest subvolume number and increment by 1
    local LAST_SV
    LAST_SV="$(find "${BTRFS_MOUNT}" -maxdepth 1 -regex ".*/root[0-9]*" -printf "%f\n" | sort -rV | head -n 1)"
    local N_LAST="${LAST_SV#root}"
    local SNAPSHOT_NAME="root$((N_LAST + 1))"

    sed -i "s|${OLD_DISKID}|${NEW_DISKID}|
            s|subvol=/root|subvol=/${SNAPSHOT_NAME}|" \
        "${SNAPSHOT_TEMP}/etc/fstab"
    # Remove firstboot script as init
    sed -i "s|subvol=\S*|subvol=/${SNAPSHOT_NAME}|
            s|${OLD_DISKID}|${NEW_DISKID}|
            s| init=\S*||
            s| quiet||" \
        "${SNAPSHOT_TEMP}/boot-save/cmdline.txt"

    # Finalize by renaming from root-temp
    mv -T "${SNAPSHOT_TEMP}" "${BTRFS_MOUNT}/${SNAPSHOT_NAME}"
    printf "Created new installation as subvolume %s\n" "${SNAPSHOT_NAME}"

    trap - ERR
    _clean_install

    if [[ ${STAGE} == 1 ]]; then
        stage "${SNAPSHOT_NAME}"
    fi
}

function _clean_install {
    umount -R "${IMAGE_MOUNT}" || true
    losetup -d "${LOOP_DEV}" || true
}

function list_images {
    local STAGED
    while getopts 'rs' OPTION
    do
        case ${OPTION} in
            r) running_subvol
                exit 0
                ;;
            s) STAGED="$(staged_subvol)"
                if [[ -z "${STAGED}" ]]; then
                    echo "No subvolume staged currently" >&2
                    exit 9
                else
                    echo "${STAGED}"
                fi
                exit 0
                ;;
            ?) printf "Usage:\n%s\n" "$(usage_list)" >&2
                exit 2
                ;;
        esac
    done

    mount_btrfs_top
    #TODO: Print additional information
    find "${BTRFS_MOUNT}" -maxdepth 1 -regex ".*/root[0-9]*" -printf "%f\n" | sort -V
}

function prune_subvolumes {
    local N_KEEP=2
    local CMD=(btrfs subvolume delete --commit-after)
    while getopts 'dk:' OPTION
    do
        case ${OPTION} in
            d) CMD=(printf "%s\n")
                ;;
            k) N_KEEP="${OPTARG}"
                ;;
            ?) printf "Usage:\n%s\n" "$(usage_prune)" >&2
                exit 2
                ;;
        esac
    done

    local STAGED
    local RUNNING
    STAGED="$(staged_subvol)"
    RUNNING="$(running_subvol)"

    mount_btrfs_top
    find "${BTRFS_MOUNT}" -maxdepth 1 -regex ".*/root[0-9]*" \   # List installations
            \! -name "${STAGED}" \! -name "${RUNNING}" -print0 | # Filter out staged and running
        sort -zV |
        head -zn "-${N_KEEP}" |  # Remove N_KEEP newest
        xargs -0r "${CMD[@]}"    # Delete (or print with -d)
}

function staged_subvol {
    if [[ -f /boot/tryboot/cmdline.txt ]]; then
        _get_root_subvol /boot/tryboot/cmdline.txt
    fi
}

function running_subvol {
    _get_root_subvol /boot/cmdline.txt
}

function _get_root_subvol {
    # Parse a kernel command line for the root subvolume name
    grep -oP -m 1 "rootflags=subvol=(\S*/)?\K[^/\s]*" "$1"
}

function stage {
    local FORCE=0
    while getopts 'fp' OPTION
    do
        case ${OPTION} in
            f) FORCE=1
                ;;
            ?) printf "Usage:\n%s\n" "$(usage_stage)" >&2
                exit 2
                ;;
        esac
    done
    shift $((OPTIND - 1))
    unset OPTIND

    if [[ $# != 1 ]]; then
        printf "No subvolume to stage specified. Usage:\n%s\n" "$(usage_stage)" >&2
        exit 2
    fi

    mount_btrfs_top
    local SUBVOL
    SUBVOL="$(find_subvolume "$1")"

    # Check if something is already staged
    if [[ -f /boot/tryboot.txt ]]; then
        if [[ ${FORCE} == 1 ]]; then
            echo "A subvolume is already staged, overwriting..."
            unstage
        else
            echo "A subvolume is already staged. Overwrite with -f" >&2
            exit 2
        fi
    fi

    rsync -a "${SUBVOL}/boot-save/" /boot/tryboot
    cp /boot/tryboot/config.txt /boot/tryboot.txt
    echo -e "\nos_prefix=tryboot/" >> /boot/tryboot.txt
    printf "Staged %s. Run the installation with '%s reboot'.\n" "${SUBVOL}" "${0##*/}"
}

function unstage {
    #TODO: Save tryboot contents back into boot-save
    rm -rf /boot/tryboot
    rm -f /boot/tryboot.txt
}

function boot_into {
    if [[ ! -f /boot/tryboot.txt ]]; then
        printf "No installation staged. Use '%s' first.\n" "$(usage_stage)" >&2
        exit 4
    fi
    echo "Rebooting"
    reboot '0 tryboot'
}

function persist {
    rsync -a /boot/tryboot/ /boot/ --delete
    unstage
    printf "Installation will now persist across regular reboots"
}

while getopts 'h' OPTION
do
    case ${OPTION} in
        h) usage_all
            exit 0
            ;;
        ?) printf "Invalid!\n" >&2
            exit 2
            ;;
    esac
done

shift $((OPTIND - 1))
unset OPTIND

FUNCTION=$1
shift

case ${FUNCTION} in
    install) install_img "$@"
        ;;
    list) list_images "$@"
        ;;
    prune) prune_subvolumes "$@"
        ;;
    stage) stage "$@"
        ;;
    unstage) unstage "$@"
        ;;
    reboot) boot_into "$@"
        ;;
    persist) persist "$@"
        ;;
    *) printf "Function %s not recognized\n" "${FUNCTION}" >&2
        exit 2
        ;;
esac
