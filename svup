#!/bin/bash
# vim: ft=sh

set -e

# Mountpoint for top-level btrfs subvolume, must be listed in /etc/fstab
BTRFS_TOP_MOUNT="/root/btrfs-top-lvl"

function usage_install {
    printf "%s install [-s] [-b BASE] IMAGE\n" ${0##*/}
}

function usage_list {
    printf "%s list\n" ${0##*/}
}

function usage_prune {
    printf "%s prune [-k KEEP]\n" ${0##*/}
}

function usage_stage {
    printf "%s stage [-f] SNAPSHOT\n" ${0##*/}
}

function usage_unstage {
    printf "%s unstage\n" ${0##*/}
}

function usage_reboot {
    printf "%s reboot\n" ${0##*/}
}

function usage_persist {
    printf "%s persist\n" ${0##*/}
}

function usage_all {
    cat <<EOF
Usage:
${0##*/} [global] <command> [<args>]

Global Options:
    -h  Show this help message
    -v  Verbose output

Usage of subcommands:

$(usage_install)
    Install IMAGE under a new snapshot.
    -s also stages that installation afterwards.
    A different base subvolume can be specified with -b which will be the basis
    for the snapshot instead of the currently running subvolume.
$(usage_list)
    List all currently installed images
$(usage_prune)
    Prune subvolumes with unused installations, keeping KEEP newest volumes.
    Defaults to keeping 3 volumes.
$(usage_stage)
    Prepare a snapshot for booting with ${0##*/} reboot.
    If -f (force) is specified, overwrite any existing configuration for
    another subvolume.
$(usage_unstage)
    Unstage the currently staged version again
$(usage_reboot)
    Try booting into the staged version
$(usage_persist)
    Confirm that the new version works and make it persistent across regular
    reboots.
EOF
}


# Ensures btrfs top-level subvolume is mounted
function mount_btrfs_top {
    ROOT_DEV="$(findmnt -nv -o source /)"
    if ! findmnt "${BTRFS_TOP_MOUNT}" > /dev/null; then
        mount -t btrfs "${ROOT_DEV}" "${BTRFS_TOP_MOUNT}"
    fi
}

function install_img {
    local STAGE=0
    local BASE="/"
    while getopts 'sb:' OPTION
    do
        case ${OPTION} in
            s) STAGE=1
                ;;
            b) BASE="${OPTARG}"
                ;;
            ?) printf "Usage:\n%s\n" "$(usage_install)" >&2
                exit 2
                ;;
        esac
    done
    shift $((${OPTIND} - 1))
    unset OPTIND

    if [[ $# != 1 ]]; then
        printf "Missing image path\n%s\n" "$(usage_install)" >&2
        exit 2
    fi
    local IMAGE_PATH="$1"
    IMAGE_MOUNT="/mnt/svup/image"

    #TODO Image validation

    LOOP_DEV=$(losetup -f -P --show "${IMAGE_PATH}")

    # Unmount image when encountering any error
    trap 'echo "An error occured during installation, cleaning up"; _clean_install' ERR

    mkdir -p ${IMAGE_MOUNT}
    mount -o ro,subvol=/root -t btrfs "${LOOP_DEV}p2" ${IMAGE_MOUNT}
    mount -o ro -t vfat "${LOOP_DEV}p1" "${IMAGE_MOUNT}/boot"

    mount_btrfs_top

    local SNAPSHOT_TEMP="${BTRFS_TOP_MOUNT}/root-temp"
    if [[ -e "${SNAPSHOT_TEMP}" ]]; then
        echo "Partial installation from a previous aborted run found. Deleting..."
        btrfs subvolume delete "${SNAPSHOT_TEMP}"
    fi

    local LAST_SV=$(ls -vd "${BTRFS_TOP_MOUNT}"/root* | tail -n 1)
    local N_LAST="${LAST_SV##*root}"

    local SNAPSHOT_NAME="root$((N_LAST + 1))"
    local SNAPSHOT_PATH="${BTRFS_TOP_MOUNT}/${SNAPSHOT_NAME}"
    btrfs subvolume snapshot "${BASE}" "${SNAPSHOT_TEMP}"

    # Copy over changes
    rsync --delete --inplace -aAXHx \
        -f ". ${SNAPSHOT_TEMP}/usr/share/svup/upgrade.filter" \
        --info=stats2,progress2,misc1,flist0 \
        "${IMAGE_MOUNT}/" "${SNAPSHOT_TEMP}"

    # Put /boot into /boot-save
    rsync -a "${IMAGE_MOUNT}/boot/" "${SNAPSHOT_TEMP}/boot-save"

    # Modify /etc/fstab and /boot/cmdline.txt:
    # Set the correct subvolume and use the current PARTUUID
    local OLD_DISKID=$(grep -oP "(?<=PARTUUID=)[0-9a-f]+(?=.*\s/\s)" \
        "${SNAPSHOT_TEMP}/etc/fstab" | head -n 1)
    local NEW_DISKID=$(lsblk -no PTUUID "${ROOT_DEV}")

    sed -i "s|${OLD_DISKID}|${NEW_DISKID}|
            s|subvol=/root|subvol=/${SNAPSHOT_NAME}|" \
        "${SNAPSHOT_TEMP}/etc/fstab"
    # Remove firstboot script as init
    sed -i "s|subvol=\S*|subvol=/${SNAPSHOT_NAME}|
            s|${OLD_DISKID}|${NEW_DISKID}|
            s| init=\S*||
            s| quiet||" \
        "${SNAPSHOT_TEMP}/boot-save/cmdline.txt"

    # Finalize by renaming from root-temp
    mv "${SNAPSHOT_TEMP}" "${SNAPSHOT_PATH}"
    printf "Created new installation as subvolume %s\n" "${SNAPSHOT_NAME}"

    trap - ERR
    _clean_install

    if [[ ${STAGE} == 1 ]]; then
        stage "${SNAPSHOT_NAME}"
    fi
}

function _clean_install {
    umount -R "${IMAGE_MOUNT}" || true
    losetup -d "${LOOP_DEV}" || true
}

function list_images {
    mount_btrfs_top
    #TODO: Print additional information
    find "${BTRFS_TOP_MOUNT}" -maxdepth 1 -name "root*" -printf "%f\n"
}

function prune_subvolumes {
    local N_KEEP=3
    while getopts 'k:' OPTION
    do
        case ${OPTION} in
            k) N_KEEP="${OPTARG}"
                ;;
            ?) printf "Usage:\n%s\n" "$(usage_prune)" >&2
                exit 2
                ;;
        esac
    done

    mount_btrfs_top
    #TODO: Make sure not to delete running or staged volumes
    btrfs subvolume delete --commit-after $(ls "${BTRFS_TOP_MOUNT}" | tail -n "+${N_KEEP}")
}

function stage {
    local FORCE=0
    while getopts 'f' OPTION
    do
        case ${OPTION} in
            f) FORCE=1
                ;;
            ?) printf "Usage:\n%s\n" "$(usage_stage)" >&2
                exit 2
                ;;
        esac
    done
    shift $((${OPTIND} - 1))
    unset OPTIND

    if [[ $# != 1 ]]; then
        printf "No subvolume to stage specified. Usage:\n%s\n" "$(usage_stage)" >&2
        exit 2
    fi
    local SUBVOL=$1

    if [[ -f /boot/tryboot.txt ]]; then
        if [[ ${FORCE} == 1 ]]; then
            echo "A subvolume is already staged, overwriting..."
            unstage
        else
            echo "A subvolume is already staged. Overwrite with -f" >&2
            exit 2
        fi
    fi

    mount_btrfs_top

    rsync -a "${SUBVOL}/boot-save/" /boot/tryboot
    cp /boot/tryboot/config.txt /boot/tryboot.txt
    echo -e "\nos_prefix=tryboot/" >> /boot/tryboot.txt
    printf "Staged %s. Run the installation with '%s reboot'.\n" "${SUBVOL}" ${0##*/}
}

function unstage {
    rm -rf /boot/tryboot
    rm -f /boot/tryboot.txt
}

function boot_into {
    echo "Rebooting"
    reboot '0 tryboot'
}

function persist {
    rsync -a /boot/tryboot/ /boot/ --delete
    unstage
    printf "Installation will now persist across regular reboots"
}

VERBOSE=0
QUIET=0

while getopts 'vh' OPTION
do
    case ${OPTION} in
        v) VERBOSE=1
            ;;
        h) usage_all
            exit 0
            ;;
        ?) printf "Invalid!\n" >&2
            exit 2
            ;;
    esac
done

shift $((${OPTIND} - 1))
unset OPTIND

if [[ "${VERBOSE}" == 1 ]]; then
    echo "Verbose!"
fi

if [[ "${QUIET}" == 1 ]]; then
    echo "quiet"
fi

FUNCTION=$1
shift

case ${FUNCTION} in
    install) install_img $@
        ;;
    list) list_images $@
        ;;
    prune) prune_subvolumes $@
        ;;
    stage) stage $@
        ;;
    unstage) unstage $@
        ;;
    reboot) boot_into $@
        ;;
    persist) persist $@
        ;;
    *) printf "Function ${FUNCTION} not recognized\n" >&2
        exit 2
        ;;
esac
